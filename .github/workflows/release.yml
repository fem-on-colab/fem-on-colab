name: Release new FEM on Colab package

on:
  workflow_dispatch:
    inputs:
      library:
        description: "Library to build"
      task:
        description: "Task to be done: package (default) or test. If empty, a package job is requested"

jobs:
  build:
    runs-on: ubuntu-latest
    container: ubuntu:18.04
    steps:
      - name: Store the current date and time
        id: date_time
        run: echo "::set-output name=date_time::$(date '+%Y%m%d-%H%M%S')"
      - name: Install git
        run: |
          apt update -qq
          apt install -y -qq software-properties-common
          add-apt-repository ppa:git-core/ppa
          apt update -qq
          apt install -y -qq git
      - uses: actions/checkout@v2
      - name: Compute short SHA of the commit
        id: sha_short
        run: echo "::set-output name=sha_short::$(git rev-parse --short HEAD)"
      - name: Print release name, release date, git commit sha and task
        run: echo "${{ github.event.inputs.library }} ${{ steps.date_time.outputs.date_time }} ${{ steps.sha_short.outputs.sha_short }} ${{ github.event.inputs.task }}"
      - name: Determine which token to use when cloning website repository
        if: github.event.inputs.task != 'test'
        id: token_website
        run: |
          if [[ "${GITHUB_REPOSITORY}" == "fem-on-colab/fem-on-colab" ]]; then
            echo "::set-output name=token::${{ secrets.REPO_ACCESS_TOKEN }}"
          else
            echo "::set-output name=token::${{ github.token }}"
          fi
        shell: bash
      - name: Clone website repository
        if: github.event.inputs.task != 'test'
        uses: actions/checkout@v2
        with:
          repository: fem-on-colab/fem-on-colab.github.io
          token: ${{ steps.token_website.outputs.token }}
          ref: gh-pages
          fetch-depth: 0
          path: _build/html
      - name: Determine latest releases from website repository
        if: github.event.inputs.task != 'test'
        id: releases_website
        run: |
          LIBRARY=${{ github.event.inputs.library }}
          pushd _build/html
          WEBSITE_FETCH_URL=$(git remote get-url origin)
          WEBSITE_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          WEBSITE_RAW_PREFIX="${WEBSITE_FETCH_URL}/raw"
          RELEASED_LIBRARIES=($(git ls-tree -r ${WEBSITE_BRANCH} --name-only -- releases | sed "s|releases/||" | sed "s|-install.sh||"))
          declare -a RELEASE_INSTALL_SCRIPT_ENVS
          declare -a RELEASE_INSTALL_SCRIPT_RAW_URLS
          for RELEASED_LIBRARY in "${RELEASED_LIBRARIES[@]}"; do
            if [[ "${RELEASED_LIBRARY}" != "${LIBRARY}" ]]; then
              RELEASED_LIBRARY_CAPITAL=$(echo ${RELEASED_LIBRARY} | tr a-z A-Z)
              RELEASE_COMMIT=$(git rev-parse --short $(git rev-list -1 ${WEBSITE_BRANCH} -- releases/${RELEASED_LIBRARY}-install.sh))
              RELEASE_INSTALL_SCRIPT_ENVS+=(${RELEASED_LIBRARY_CAPITAL}_INSTALL_SCRIPT_PATH)
              RELEASE_INSTALL_SCRIPT_RAW_URLS+=(${WEBSITE_RAW_PREFIX}/${RELEASE_COMMIT}/releases/${RELEASED_LIBRARY}-install.sh)
            fi
          done
          echo "::set-output name=release_install_script_envs::${RELEASE_INSTALL_SCRIPT_ENVS[@]}"
          echo "::set-output name=release_install_script_raw_urls::${RELEASE_INSTALL_SCRIPT_RAW_URLS[@]}"
          popd
        shell: bash
      - name: Setup Colab base image
        id: colab
        run: |
          source ./colab/install.sh
          echo "::set-output name=path::${PATH}"
          echo "::set-output name=ld_library_path::${LD_LIBRARY_PATH}"
          echo "::set-output name=pythonpath::${PYTHONPATH}"
          echo "::set-output name=install_prefix::${INSTALL_PREFIX}"
          echo "::set-output name=cppflags::${CPPFLAGS}"
          echo "::set-output name=ldflags::${LDFLAGS}"
        shell: bash
      - name: Build library
        if: github.event.inputs.task != 'test'
        run: |
          LIBRARY=${{ github.event.inputs.library }}
          if [[ -f ${LIBRARY}/build.sh ]]; then
            RELEASE_INSTALL_SCRIPT_ENVS=(${{ steps.releases_website.outputs.release_install_script_envs }})
            RELEASE_INSTALL_SCRIPT_RAW_URLS=(${{ steps.releases_website.outputs.release_install_script_raw_urls }})
            for I in "${!RELEASE_INSTALL_SCRIPT_ENVS[@]}"; do
              declare -x "${RELEASE_INSTALL_SCRIPT_ENVS[I]}"="${RELEASE_INSTALL_SCRIPT_RAW_URLS[I]}"
            done
            bash ${LIBRARY}/build.sh
          fi
        env:
          PATH: ${{ steps.colab.outputs.path }}
          LD_LIBRARY_PATH: ${{ steps.colab.outputs.ld_library_path }}
          PYTHONPATH: ${{ steps.colab.outputs.pythonpath }}
          INSTALL_PREFIX: ${{ steps.colab.outputs.install_prefix }}
          CPPFLAGS: ${{ steps.colab.outputs.cppflags }}
          LDFLAGS: ${{ steps.colab.outputs.ldflags }}
          VERBOSE: 1
          V: 1
        shell: bash
      - name: Look for libstdc++.so in ldd of generated libraries
        if: github.event.inputs.task != 'test'
        run: |
          ERROR_LIBRARIES=($(find $INSTALL_PREFIX -name '*\.so' -exec bash -c 'ldd $0 | grep libstdc++.so.6 1>/dev/null 2>/dev/null && echo $0' {} \;))
          if [ ${#ERROR_LIBRARIES[@]} -eq 0 ]; then
            echo "No reference to libstdc++.so was found"
          else
            for ERROR_LIBRARY in "${ERROR_LIBRARIES[@]}"; do
              echo "Error: library $ERROR_LIBRARY depends on libstdc++.so"
              ldd -v $ERROR_LIBRARY
            done
            false
          fi
        env:
          INSTALL_PREFIX: ${{ steps.colab.outputs.install_prefix }}
        shell: bash
      - name: Package library
        if: github.event.inputs.task != 'test'
        run: |
          LIBRARY=${{ github.event.inputs.library }}
          DEPENDENCIES=($(find /tmp -name '*-install\.tar.gz'))
          if [ "${#DEPENDENCIES[@]}" -gt "0" ]; then
            source scripts/prepare_for_installation.sh ${LIBRARY}-full
            source scripts/remove_dependencies_from_archive.sh ${LIBRARY} $PWD/${LIBRARY}-full-install.tar.gz ${DEPENDENCIES[@]}
          else
            source scripts/prepare_for_installation.sh ${LIBRARY}
          fi
        env:
          PATH: ${{ steps.colab.outputs.path }}
          LD_LIBRARY_PATH: ${{ steps.colab.outputs.ld_library_path }}
          PYTHONPATH: ${{ steps.colab.outputs.pythonpath }}
          INSTALL_PREFIX: ${{ steps.colab.outputs.install_prefix }}
        shell: bash
      - name: Test library
        run: |
          LIBRARY=${{ github.event.inputs.library }}
          TASK=${{ github.event.inputs.task }}
          if [[ "${TASK}" != "test" ]]; then
            RELEASE_INSTALL_SCRIPT_ENVS=(${{ steps.releases_website.outputs.release_install_script_envs }})
            RELEASE_INSTALL_SCRIPT_RAW_URLS=(${{ steps.releases_website.outputs.release_install_script_raw_urls }})
            for I in "${!RELEASE_INSTALL_SCRIPT_ENVS[@]}"; do
              declare -x "${RELEASE_INSTALL_SCRIPT_ENVS[I]}"="${RELEASE_INSTALL_SCRIPT_RAW_URLS[I]}"
            done
            LIBRARY_CAPITAL=$(echo ${LIBRARY} | tr a-z A-Z)
            declare -x "${LIBRARY_CAPITAL}_ARCHIVE_PATH"="$PWD/${LIBRARY}-install.tar.gz"
            bash ${LIBRARY}/install.sh
          else
            IFS=: read -r -a PYTHONPATH_ARRAY <<< "$PYTHONPATH"
            cp -rf colab/patches/google ${PYTHONPATH_ARRAY[-1]}/
          fi
          LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libstdc++.so.6 pytest --nbval ${LIBRARY}/
        env:
          PATH: ${{ steps.colab.outputs.path }}
          PYTHONPATH: ${{ steps.colab.outputs.pythonpath }}
        shell: bash
      - name: Check if a release is needed
        if: github.event.inputs.task != 'test'
        id: check_release
        run: |
          LIBRARY=${{ github.event.inputs.library }}
          [[ -f "${LIBRARY}/build.sh" ]] && NEEDS_RELEASE="yes" || NEEDS_RELEASE="no"
          echo "::set-output name=needs_release::${NEEDS_RELEASE}"
        shell: bash
      - name: Add release to repository
        if: github.event.inputs.task != 'test' && steps.check_release.outputs.needs_release == 'yes'
        uses: marvinpinto/action-automatic-releases@latest
        with:
          repo_token: ${{ secrets.REPO_ACCESS_TOKEN }}
          automatic_release_tag: ${{ github.event.inputs.library }}-${{ steps.date_time.outputs.date_time }}-${{ steps.sha_short.outputs.sha_short }}
          title: "${{ github.event.inputs.library }} ${{ steps.date_time.outputs.date_time }} ${{ steps.sha_short.outputs.sha_short }}"
          files: ${{ github.event.inputs.library }}-install.tar.gz
      - name: Prepare release file for website
        if: github.event.inputs.task != 'test'
        run: |
          LIBRARY=${{ github.event.inputs.library }}
          LIBRARY_CAPITAL=$(echo ${LIBRARY} | tr a-z A-Z)
          DATETIME=${{ steps.date_time.outputs.date_time }}
          SHA_SHORT=${{ steps.sha_short.outputs.sha_short }}
          RELEASE_INSTALL_SCRIPT_ENVS=(${{ steps.releases_website.outputs.release_install_script_envs }})
          RELEASE_INSTALL_SCRIPT_RAW_URLS=(${{ steps.releases_website.outputs.release_install_script_raw_urls }})
          cp ./${LIBRARY}/install.sh _build/html/releases/${LIBRARY}-install.sh
          for I in "${!RELEASE_INSTALL_SCRIPT_ENVS[@]}"; do
            sed -i "s|${RELEASE_INSTALL_SCRIPT_ENVS[I]}_IN|${RELEASE_INSTALL_SCRIPT_RAW_URLS[I]}|g" _build/html/releases/${LIBRARY}-install.sh
          done
          sed -i "s|${LIBRARY_CAPITAL}_ARCHIVE_PATH_IN|https://github.com/fem-on-colab/fem-on-colab/releases/download/${LIBRARY}-${DATETIME}-${SHA_SHORT}/${LIBRARY}-install.tar.gz|g" _build/html/releases/${LIBRARY}-install.sh
        shell: bash
      - name: Upload release file to website
        if: github.event.inputs.task != 'test' && github.repository == 'fem-on-colab/fem-on-colab'
        run: |
          LIBRARY=${{ github.event.inputs.library }}
          SHA_SHORT=${{ steps.sha_short.outputs.sha_short }}
          pushd _build/html
          git config user.name "GitHub Actions"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add releases/${LIBRARY}-install.sh
          git commit -m "deploy: ${GITHUB_REPOSITORY}@${SHA_SHORT}"
          WEBSITE_BRANCH=$(git branch --show-current)
          git push origin ${WEBSITE_BRANCH}
          popd
        shell: bash
      - name: Create an archive of build directory and install prefix in case of failure
        if: failure()
        run: |
          if compgen -G "/tmp/*-src" > /dev/null; then
            tar czf build.tar.gz /tmp/*-src
          fi
          tar czf install-prefix.tar.gz ${{ steps.colab.outputs.install_prefix }}
      - name: Upload archives as an artifact in case of failure
        if: failure()
        uses: actions/upload-artifact@v2
        with:
          path: |
            build.tar.gz
            install-prefix.tar.gz
            ${{ github.event.inputs.library }}-install.tar.gz
